#!/bin/bash

process() {
	# parse out the payload
	eval $(echo "${POST[payload]}" | ./json_bash payload)
	if [[ "${payload_repository_url:0:28}" != "https://github.com/brimstone" ]]; then
		echo "not a valid url: $payload_repository_url"
		return
	fi
	echo "$(date) Processing request for $payload_repository_name"
	# figure out our directory
	dir="$(basename "$payload_repository_url")"
	(
	echo "Commit $payload_after by $payload_head_commit_author_name ($payload_head_commit_author_username) $payload_head_commit_author_email"
	echo "\"$payload_head_commit_message\""
	echo
	# clone the repo
	echo "Cloning $payload_repository_url"
	git clone "$payload_repository_url"
	cd "$dir"
	if [ -e ".gitmodules" ]; then
		git submodule update --recursive --init
	fi
	if [ -e "build" ]; then
		echo "Running build script"
		echo
		./build
		ret=$?
	elif [ -e "Makefile" ]; then
		echo "Running make"
		echo
		make
		ret=$?
		if [ $ret == 0 ] && grep -q "^test:" Makefile; then
			make test
			ret=$?
		fi
	fi
	cd ..
	rm -rf "$dir"
	echo "Exit code: $ret"
	[ $ret != 0 ] && exit $ret
	exit 0
	) 2>&1 3>&2 | (
		while read aline; do
			if [ -z "$aline" ]; then
				echo
			else
				echo "$(date) $aline"
			fi
		done
	) > $dir.log
	ret=${PIPESTATUS[0]}
	userrepo=${payload_repository_url##https://github.com/}
	# check for a current broken build issue
	issueid=$(ghi list -L build -- $userrepo | awk '/Build/ { print $1 }')
	if [ $ret == 0 ]; then
		# build was clean
		echo "Build was clean"
		# if we're currently broken
		# close our current issue id
		if [ -n "$issueid" ]; then
			ghi close $issueid -m "$(< $dir.log)" -- $userrepo
		fi
	else
		# build broke
		echo "build broke"
		# If email:
		#mail -s "Build of $payload_repository_name FAILED" brimstone@the.narro.ws < $dir.log

		# if we don't have a current issue
		if [ -z "$issueid" ]; then
		# open one
		ghi open -m "Build FAILED
$(< $dir.log)" -L build -- $userrepo
		else
			ghi comment -m "$(< $dir.log)" $issueid -- $userrepo
		fi

	fi
	rm $dir.log
}

trap 'kill $COPROC_PID;exit' INT

while true; do
	# listen on a port, mapping file handles to the $COPROC array
	coproc nc -lp 8081 2>/dev/null
	# first read our verb, url and http version
	read -u "${COPROC[0]}" ENV_verb ENV_url ENV_http
	# trim the \r
	# TODO make this not fail when nc gets the SIGTERM
	ENV_http="${ENV_http:0:$[ ${#ENV_http} - 1 ]}"
	# now read all of the headers from the stdout of coproc
	while read -u "${COPROC[0]}" aline; do
		# trim the \r
		aline="${aline:0:$[ ${#aline} - 1 ]}"
		# if we're at the end of our headers, and our input is a blank line
		if [ -z "${aline}" ]; then
			# wait! if our verb is POST, then we need to also read some more data from the client
			if [ "$ENV_verb" = "POST" ]; then
				read -n "$ENV_Content_Length" -u "${COPROC[0]}" POSTDATA
				# split on the & first
				declare -A POST
				for d in $(echo "$POSTDATA" | tr '&' '\n'); do
					# then split on the =
					key="${d%%=*}"
					# then decode everything
					POST[$key]="$(echo -e "$(echo "${d#*=}" | sed -E 's/\+/ /g;s/%([0-9A-F]{2})/\\x\1/g')")"
				done
			fi
			# right now, just echo out our variables and bail
			break
		fi
		# split up the header line and set environment variables accordingly
		key="${aline%%: *}"
		eval export "ENV_${key//-/_}"="\"${aline#*: }\""
	done
	
	process

	# we're done with what the user gave us, so kill the socket
	kill "$COPROC_PID"
	# wait to make sure the socket is dead before starting it back again
	wait "$COPROC_PID"
done
